Metadata-Version: 2.4
Name: dependency-mapper
Version: 0.1.0
Summary: A tool to generate a topological dependency graph from a codebase.
Requires-Python: >=3.8
Description-Content-Type: text/markdown
Requires-Dist: pydantic>=2.0
Requires-Dist: networkx>=3.0
Requires-Dist: astroid>=3.0
Requires-Dist: pydot>=2.0.0

# Topology Grapher

[![Build Status](https://img.shields.io/badge/build-passing-brightgreen)](https://github.com/deepfence/TopologyGrapher)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

The Topology Grapher is a powerful command-line tool for analyzing source code to generate a detailed dependency graph. It parses multi-language codebases to understand the relationships between different components, such as files, classes, functions, and variables.

## Role in the Deepfence.AI Platform

The Topology Grapher is a foundational component of the Deepfence.AI security and observability platform. The dependency graph it generates is a critical data source that enables Deepfence to provide deep, context-aware insights into application architecture and security posture.

-   **Attack Path Analysis**: By understanding how different parts of the code are connected, Deepfence can map potential attack paths, identifying how a vulnerability in one component could be exploited to compromise another.
-   **Blast Radius Assessment**: When a vulnerability is discovered, the graph helps determine the "blast radius"—all other components that depend on or interact with the vulnerable code, allowing for precise risk assessment.
-   **Prioritization of Findings**: The graph provides the structural context needed to prioritize security findings. A vulnerability in a core, highly-connected library is more critical than one in an isolated, unused module.
-   **Runtime Correlation**: The static graph generated by this tool can be correlated with runtime observations to provide a complete picture of application behavior, highlighting unused "dead code" or unexpected runtime dependencies.

In essence, the Topology Grapher creates the architectural blueprint that powers Deepfence's advanced security analytics.

## Features

-   **Multi-Language Support**: Concurrently analyzes Python and TypeScript/JavaScript codebases.
-   **High-Performance Analysis**: Utilizes parallel processing to analyze large codebases quickly.
-   **Rich Dependency Mapping**: Identifies a wide range of relationships:
    -   File imports and module dependencies.
    -   Function/method calls.
    -   Class inheritance and interface implementation.
    -   Type hint and annotation usage.
    -   Variable and attribute access.
-   **Circular Dependency Detection**: Performs a topological sort to identify and report cyclic dependencies that can complicate build processes and indicate architectural issues.
-   **Flexible Output Formats**:
    -   **JSON**: For easy integration with other tools and platforms.
    -   **DOT**: For direct visualization using Graphviz.

## Installation

### Prerequisites

-   Python 3.8+
-   Node.js 16+ (for TypeScript/JavaScript parsing)
-   Git (recommended for efficient file discovery)

### Setup Steps

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/deepfence/TopologyGrapher.git
    cd TopologyGrapher
    ```

2.  **Install Python dependencies:**
    It is recommended to use a virtual environment.
    ```bash
    python -m venv .venv
    source .venv/bin/activate
    pip install -e .
    ```

3.  **Install Node.js dependencies for the TypeScript parser:**
    ```bash
    cd src/ts_parser
    npm install
    cd ../..
    ```

## Usage

The tool is run from the command line via the `dependency-mapper` entry point.

### Basic Command

```bash
dependency-mapper <path_to_codebase> [options]
```

### Arguments and Options

-   `root_path`: (Required) The path to the root directory of the codebase you want to analyze.
-   `--output, -o`: Path to save the output file. If omitted, the graph is printed to standard output.
-   `--format, -f`: The output format. Choices: `json` (default), `dot`.
-   `--workers, -w`: The number of parallel worker processes to use. Defaults to the number of available CPU cores.
-   `--show-layers`: Instead of printing the graph, performs a topological sort and prints the analysis layers. This is useful for detecting circular dependencies.

### Examples

1.  **Analyze a project and print the JSON graph to the console:**
    ```bash
    dependency-mapper /path/to/my-project
    ```

2.  **Save the graph as a DOT file for visualization:**
    ```bash
    dependency-mapper /path/to/my-project --format dot --output graph.dot
    ```
    You can then generate an image from this file using Graphviz:
    ```bash
    dot -Tpng graph.dot -o graph.png
    ```

3.  **Check for circular dependencies and view analysis layers:**
    ```bash
    dependency-mapper /path/to/my-project --show-layers
    ```

## Project Structure

```
topology-grapher/
├── src/
│   ├── dependency_mapper/
│   │   ├── parsers/
│   │   │   ├── python_parser.py     # Parses Python code using astroid
│   │   │   └── typescript_parser.py # Python wrapper for the TS/JS parser
│   │   ├── ts_parser/
│   │   │   ├── index.js             # Standalone Node.js TS/JS parser using ts-morph
│   │   │   └── package.json         # Node.js dependencies
│   │   ├── api.py                   # Top-level API functions (generate_graph)
│   │   ├── cli.py                   # Command-line interface logic (argparse)
│   │   ├── graph_builder.py         # Constructs the networkx graph
│   │   ├── models.py                # Pydantic models for Node, Edge, etc.
│   │   ├── orchestrator.py          # Manages parallel file parsing
│   │   ├── serializers.py           # Handles JSON and DOT output formatting
│   │   └── walkers.py               # Discovers source files to be parsed
│   └── ts_parser/
├── tests/                           # Unit and integration tests
├── pyproject.toml                   # Project metadata and Python dependencies
└── README.md                        # This file
```

## How It Works

The analysis process is broken down into four main stages:

1.  **File Discovery**: The `walkers` module identifies all relevant source files. It intelligently uses `git ls-files` for speed and accuracy in Git repositories, falling back to a recursive file system search if needed.
2.  **Parallel Parsing**: The `orchestrator` manages a pool of worker processes to parse files in parallel. It delegates files to the appropriate language parser based on their extension.
    -   **Python**: The `python_parser` uses `astroid` to build an Abstract Syntax Tree (AST) and traverses it to find nodes (classes, functions) and edges (calls, imports, inheritance).
    -   **TypeScript/JavaScript**: The `typescript_parser` invokes a standalone Node.js script in `ts_parser/`. This script uses `ts-morph` to analyze the code and returns its findings as a JSON object.
3.  **Graph Construction**: The `graph_builder` collects the nodes and edges from all parsers and uses the `networkx` library to construct a single, unified directed graph (`DiGraph`).
4.  **Output & Serialization**: The `cli` module takes the final graph and, using the `serializers` module, converts it into the user-specified format (JSON or DOT).

## Contributing

Contributions are welcome! Please feel free to open an issue to report a bug or suggest a feature, or submit a pull request with your improvements.

## License

This project is licensed under the Apache License 2.0. See the [LICENSE](LICENSE) file for details.
